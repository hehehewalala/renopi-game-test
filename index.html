<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!-- 适配移动端视口，禁止缩放 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>RENOPI Solar Challenge</title>
<style>
:root {
--renopi-orange: #ff6600; --highlight: #fff700; --bg-sky-top: #74b9ff; --bg-sky-bottom: #a2cffe; --bg-ground: #34a853; --panel-frame: #b0bec5; --panel-cell-dark: #1976d2; --panel-cell-light:
#42a5f5;
}
body { margin: 0; overflow: hidden; background: #222; display: flex; justify-content: center; }
#game-container {
position: relative;
width: 100vw;
max-width: none;
height: 100vh;
background: var(--bg-sky-top);
overflow: hidden;
box-shadow: 0 0 50px rgba(0,0,0,0.5);\
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
/* 核心 CSS：禁用浏览器的默认滑动/下拉手势 */
touch-action: none; -webkit-user-select: none;
user-select: none; -webkit-touch-callout: none;
}
canvas { display: block; cursor: none; }
#ui {
position: absolute; top: 20px; width: 100%; display: flex;
justify-content: space-around; padding: 0 20px; pointer-events: none;
color: #fff; z-index: 10; text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
}
.stat-box { text-align: center; background: rgba(0,0,0,0.4); padding: 5px 15px; border-radius: 10px;
backdrop-filter: blur(4px); }
.stat-label { font-size: 12px; opacity: 0.9; }
.stat-value { font-size: 24px; font-weight: bold; color: var(--highlight); }
#overlay {
position: absolute; inset: 0; background: rgba(0,0,0,0.95);
display: none; flex-direction: column; align-items: center; justify-content: center;
color: #fff; z-index: 100; text-align: center;
}
#final-logo { font-size: 48px; font-weight: bold; margin-bottom: 20px; color: white; text-shadow: 0
0 10px rgba(255,255,255,0.5); }
.rank-tag { font-size: 36px; margin: 10px 0; font-weight: bold; }
.btn {
padding: 12px 35px; background: var(--renopi-orange); border: none;
border-radius: 25px;
font-size: 18px; font-weight: bold; cursor: pointer; color: #fff; margin-top: 20px;
}
</style>
</head>
<body>
<div id="game-container">
<div id="ui">
<div class="stat-box">
<div class="stat-label">ENERGY (kWh)</div>
<div id="score" class="stat-value">0</div>
</div>
<div class="stat-box">
<div class="stat-label">TIME (s)</div>
<div id="timer" class="stat-value">15</div>
</div>
</div>
<div id="overlay">
<div id="final-logo">RENOPI</div>
<h2>CHALLENGE COMPLETE!</h2>
<div id="rank-name" class="rank-tag">CALCULATING...</div>
<p>TOTAL POWER: <span id="final-score" style="color:var(--highlight)">0</span> kWh</p>
<p id="rank-desc" style="font-size: 14px; padding: 0 40px; color: #ccc;"></p>
<button class="btn" onclick="location.reload()">RETRY</button>
</div>
<canvas id="gameCanvas"></canvas>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');
let score = 0;
let timeLeft = 15;
let gameActive = true;
let particles = [];
let clouds = [];
let sunAngle = 0;
let audioUnlocked = false;
let panelFlash = 0;
// 确保你有一个名为 collect.mp3 的音效文件在同一目录下
const scoreSound = new Audio('collect.mp3');
scoreSound.volume = 0.5;
const PADDLE_W = 120;
const PADDLE_H = 30;
const LIGHT_SIZE = 10;
const FALL_SPEED = 3.5;
// 新增一个变量来存储光伏板的目标 X 坐标
let targetX = 0;

// *** iOS 兼容性 Polyfill: 为不支持 roundRect 的旧浏览器添加此方法 ***
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        if (typeof radius === 'undefined') {
            radius = 5; // 默认圆角半径
        }
        if (typeof radius === 'number') {
            radius = { tl: radius, tr: radius, br: radius, bl: radius };
        } else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var corner in defaultRadius) {
                radius[corner] = radius[corner] || defaultRadius[corner];
            }
        }

        this.beginPath();
        this.moveTo(x + radius.tl, y);
        this.lineTo(x + width - radius.tr, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        this.lineTo(x + width, y + height - radius.br);
        this.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
        this.lineTo(x + radius.bl, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        this.lineTo(x, y + radius.tl);
        this.quadraticCurveTo(x, y, x + radius.tl, y);
        this.closePath();
        return this;
    };
}
// *** POLYFILL 结束 ***

function resize() {
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    // 确保在调整大小时，目标位置保持在中心或当前合理位置
    targetX = canvas.width / 2;
}
window.addEventListener('resize', resize);
resize();

class LightParticle {
    constructor() {
        const sunX = canvas.width / 2;
        const sunY = 80;
        this.x = sunX + (Math.random() - 0.5) * 30;
        this.y = sunY + (Math.random() - 0.5) * 10;
        this.vy = FALL_SPEED + Math.random() * 0.5;
        this.vx = (Math.random() - 0.5) * 1.5;
    }
    update() {
        this.y += this.vy;
        this.x += this.vx;
    }
    draw() {
        ctx.save();
        ctx.fillStyle = "#FFF700";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#FFD700";
        ctx.beginPath();
        ctx.arc(this.x, this.y, LIGHT_SIZE, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

function drawBackground() {
    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
    sky.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--bg-sky-top'));
    sky.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--bg-sky-bottom'));
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-ground');
    ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15);
    const sX = canvas.width / 2;
    const sY = 80;
    const glow = ctx.createRadialGradient(sX, sY, 15, sX, sY, 60);
    glow.addColorStop(0, 'rgba(255, 102, 0, 0.5)');
    glow.addColorStop(1, 'rgba(255, 102, 0, 0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(sX, sY, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(sX, sY, 20, 0, Math.PI*2);
    ctx.fillStyle = "#FF6600";
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    clouds.forEach(c => {
        c.x += c.s;
        if(c.x > canvas.width + 100) c.x = -150;
        drawCloud(c.x, c.y);
    });
}

function drawCloud(x, y) {
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
    ctx.beginPath();
    ctx.arc(x, y, 40, 0, Math.PI*2);
    ctx.arc(x+35, y-15, 45, 0, Math.PI*2);
    ctx.arc(x+80, y-10, 40, 0, Math.PI*2);
    ctx.arc(x+100, y, 30, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
}

function drawPanel(x, y) {
    ctx.save();
    if(panelFlash > 0) {
        ctx.shadowBlur = 30 * (panelFlash / 10);
        ctx.shadowColor = "#fff700";
        panelFlash--;
    }
    const frameColor = getComputedStyle(document.documentElement).getPropertyValue('--panel-frame');
    const cellDark = getComputedStyle(document.documentElement).getPropertyValue('--panel-cell-dark');
    const cellLight = getComputedStyle(document.documentElement).getPropertyValue('--panel-cell-light');
    ctx.fillStyle = frameColor;
    ctx.beginPath();
    ctx.roundRect(x, y, PADDLE_W, PADDLE_H, 4);
    ctx.fill();
    const cellPadding = 1;
    const cellWidth = (PADDLE_W - 4 * cellPadding) / 3;
    const cellHeight = (PADDLE_H - 3 * cellPadding) / 2;
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 2; j++) {
            const cellX = x + cellPadding + i * (cellWidth + cellPadding);
            const cellY = y + cellPadding + j * (cellHeight + cellPadding);
            ctx.fillStyle = cellDark;
            ctx.fillRect(cellX, cellY, cellWidth, cellHeight);
            ctx.fillStyle = cellLight;
            ctx.beginPath();
            ctx.moveTo(cellX, cellY + cellHeight);
            ctx.lineTo(cellX + cellWidth, cellY);
            ctx.lineTo(cellX + cellWidth, cellY + cellHeight);
            ctx.closePath();
            ctx.fill();
        }
    }
    ctx.restore();
}
// 实际绘制光伏板的位置变量
let panelX = 0;
// 统一的事件处理函数，更新目标位置 targetX
function updateTargetPosition(clientX) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    targetX = (clientX - rect.left) * scaleX;
    // Unlock audio on first interaction
    if (!audioUnlocked) {
        scoreSound.play();
        scoreSound.pause();
        scoreSound.currentTime = 0;
        audioUnlocked = true;
    }
}
// PC 端鼠标事件
container.addEventListener('mousemove', e => {
    updateTargetPosition(e.clientX);
});
// 移动端触摸事件 (核心实现线性拖动)
container.addEventListener('touchstart', e => {
    if(e.touches.length > 0) updateTargetPosition(e.touches[0].clientX);
}, { passive: false });
container.addEventListener('touchmove', e => {
    e.preventDefault();
    if(e.touches.length > 0) updateTargetPosition(e.touches[0].clientX);
}, { passive: false });

function getRank(s) {
    if (s >= 380) return { name: "SOLAR GOD", desc: "You've solved the 2026 energy crisis single-handedly! A true Solar God among mortals.", color: "#FFD700" };
    if (s >= 240) return { name: "ENGINEER", desc: "Highly efficient energy capture! Your skills are a major asset to the RENIOP grid.", color: "#4cd137" };
    if (s >= 140) return { name: "INTERN", desc: "A solid start! You're officially contributing to the global green transition.", color: "#74b9ff" };
    return { name: "NOVICE", desc: "The sun is shining, but your panel isn't! Let's try that again, future energy master.", color: "#aaa" };
}

function loop() {
    if(!gameActive) return;
    drawBackground();
    // 在循环中实时更新 panelX 以跟随目标位置 targetX
    panelX = targetX - PADDLE_W/2;
    // 边界检测
    if (panelX < 0) panelX = 0;
    if (panelX > canvas.width - PADDLE_W) panelX = canvas.width - PADDLE_W;
    let py = canvas.height - 80;
    drawPanel(panelX, py);
    if(Math.random() < 0.06) particles.push(new LightParticle());
    for(let i = particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.update();
        p.draw();
        if(p.y + LIGHT_SIZE > py && p.y - LIGHT_SIZE < py + PADDLE_H && p.x > panelX && p.x < panelX + PADDLE_W) {
            particles.splice(i, 1);
            score += 10;
            document.getElementById('score').innerText = score;
            scoreSound.currentTime = 0;
            scoreSound.play();
            panelFlash = 10;
        } else if (p.y > canvas.height) {
            particles.splice(i, 1);
        }
    }
    requestAnimationFrame(loop);
}

const timerInt = setInterval(() => {
    if(gameActive) {
        timeLeft--;
        document.getElementById('timer').innerText = timeLeft;
        if(timeLeft <= 0) {
            gameActive = false;
            const rank = getRank(score);
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('rank-name').innerText = rank.name;
            document.getElementById('rank-name').style.color = rank.color;
            document.getElementById('final-score').innerText = score;
            document.getElementById('rank-desc').innerText = rank.desc;
            clearInterval(timerInt);
        }
    }
}, 1000);

window.onload = () => {
    for(let i=0; i<5; i++) {
        clouds.push({
            x: Math.random() * canvas.width, y: Math.random() * (canvas.height * 0.5), s: 0.3 + Math.random() * 0.4
        });
    }
    // 核心修复：确保 targetX 和 panelX 在第一次循环前都被正确初始化到屏幕中间
    targetX = canvas.width / 2;
    panelX = targetX - PADDLE_W / 2;
    loop();
}
</script>
</body>
</html>
